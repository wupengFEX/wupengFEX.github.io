<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>每个阶段都是崭新的一步</title>
      <link href="/2017/11/21/%E6%AF%8F%E4%B8%AA%E9%98%B6%E6%AE%B5%E9%83%BD%E6%98%AF%E5%B4%AD%E6%96%B0%E7%9A%84%E4%B8%80%E6%AD%A5/"/>
      <url>/2017/11/21/%E6%AF%8F%E4%B8%AA%E9%98%B6%E6%AE%B5%E9%83%BD%E6%98%AF%E5%B4%AD%E6%96%B0%E7%9A%84%E4%B8%80%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=26361010&auto=1&height=66"></iframe><p>工作的三个多年头了，经历了一些，体验了一些，也实践了一些，思想变化了，思维不同了，做事风格也快定型了。突然发巅想写点感悟，就像学生时代记录心情一样，记录每个难忘的瞬间。而现在，有种很强烈的感受就是，人呢是种群体动物，if you want go fast,go alone; if you want to far,go together。以前的自己可能更倾向于前者，总以为自己牛逼全家不饿，而事实又是如何？贫穷只会限制你的想象，世界很大，牛人很多，比你聪明有能力的人也很多，看到别人的优点更为重要。</p><p>和团队在一起总会有不同的收获，有不同的眼界，无论是技术上的，做事风格上的，还是做人上的，没有人愿意生活在一潭死水的生活中，都期望有一些变化和成长，变成自己想要成为的那个人，而事实上，大多数人都已经随波逐流，很庆幸我总是很幸运，总能遇到很多亦师亦友的伙伴，坦诚，信任，有话直说，也正是因为这些人才能不断成长。</p><p>如果你也还在工作的人流中淹没自己，不妨静下来，回回头，看看时间的变更，和自己的变化，再想想当初的那些不切实际却又满载鸡血的理想，撸起袖子干吧，至少做到，无愧于自己！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>webp 技术实践</title>
      <link href="/2017/10/12/WEBP-%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5/"/>
      <url>/2017/10/12/WEBP-%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>不论是 PC 还是移动端，图片一直占据着页面流量的大头，开发者们也一直在图片的大小和质量之间做着权衡。而今 webp 技术的出现，也正为解决这样一个技术瓶颈，本文介绍 webp 的同时也会介绍 <a href="https://www.mipengine.org/">MIP</a> 对于 webp 技术的实践之路。</p><h2 id="什么是-webp？"><a href="#什么是-webp？" class="headerlink" title="什么是 webp？"></a>什么是 webp？</h2><p><a href="https://developers.google.com/speed/webp/">webp</a> 是由 Google 收购 On2 Technologies 后发展出来的格式，以BSD授权条款发布。目前已经在不同厂商之间进行了尝试，如Google、Facebook、ebay、百度、腾讯、淘宝等。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>webp 的效果显而易见，在支持有损、无损、透明图片压缩的同时，据统计，webp 无损压缩后比 PNG 图片体积减少了 26%，有损图片比同类 JPEG 图像体积减少了 25-34%，以下总结了 webp 在不同指标上所能获得的提升对比：</p><ul><li>体积 &amp; 流量<ul><li>业界改造给出的数据<br>改造 webp 之后图片体积会降低很多，具体可参照 <a href="https://isparta.github.io/compare-webp/index.html#12345">webp 体积测试链接</a>，同时也可参照如下图所示<br><img src="/img/articles/webp/webptest.png" alt="业界 webp 测试"></li><li>MIP 本地测试<br><img src="/img/articles/webp/webptest1.png" alt="本地 webp 测试"></li><li>总结<ul><li>从以上测试可知，如果将体积换算成带宽，webp 不同模式下都会节省大量流量；</li><li>科技博客 Gig‍‍‍aOM 曾报道：谷歌的 Chrome 网上应用商店采用 WebP 格式图片后，每天可以节省几 TB 的带宽。Google+ 移动应用采用 WebP 图片格式后，每天节省了 50TB 数据存储空间。</li></ul></li></ul></li><li>速度<ul><li>这一部分主要取决与网络时间，所以没有确定数据，不过可以参考业界的数据；</li><li>科技博客 Gig‍‍‍aOM 曾报道：YouTube 的视频略缩图采用 WebP 格式后，网页加载速度提升了 10%；谷歌的 Chrome 网上应用商店采用 WebP 格式图片后，页面平均加载时间大约减少 1/3。</li></ul></li></ul><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>目前来说，webp 的支持程度也在不断上升，据 2017.10.12 <a href="http://caniuse.com/#search=webp">can i use</a> 显示，全球 webp 的支持程度已经达到 73.64%，</p><p><img src="/img/articles/webp/caniuse.png" alt="webp 支持程度图解"></p><p>而也正是因为这种天然的图片体积优势和发展趋势，MIP 团队也决定进行初步的实践尝试，以提升页面用户体验。</p><h2 id="如何判断浏览器支持程度？"><a href="#如何判断浏览器支持程度？" class="headerlink" title="如何判断浏览器支持程度？"></a>如何判断浏览器支持程度？</h2><p>webp 的判断方法官方也在<a href="https://developers.google.com/speed/webp/faq#how_can_i_detect_browser_support_for_webp">文档</a>中进行了总结，大致分为 3 种方式：</p><h3 id="HTML5-picture"><a href="#HTML5-picture" class="headerlink" title="HTML5 picture"></a>HTML5 picture</h3><p>这种方法不进行 webp 支持程度的判断，而是利用 html5 picture 元素的特性，允许开发者列举出多个图片地址，浏览器根据顺序展示出第一个能够展现的图片元素，如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;image/webp&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;images/webp.webp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/webp.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;webp image&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的示例在浏览器不支持 webp 图片的情况下自动回退到 jpg 格式进行展示，但 picture 的支持程度还不是很完善，开发者可以根据需求决定是否进行使用。</p><p><img src="/img/articles/webp/caniuse1.png" alt="webp 支持程度图解"></p><h3 id="嗅探"><a href="#嗅探" class="headerlink" title="嗅探"></a>嗅探</h3><p>嗅探的方式是指直接向浏览器中插入一段 base64 的 webp 图片，检测图片是否能够正常加载，依据该方法进而判断支持程度，如官方给出的嗅探函数：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check_webp_feature:</span></span><br><span class="line"><span class="comment">//   &#x27;feature&#x27; can be one of &#x27;lossy&#x27;, &#x27;lossless&#x27;, &#x27;alpha&#x27; or &#x27;animation&#x27;.</span></span><br><span class="line"><span class="comment">//   &#x27;callback(feature, result)&#x27; will be passed back the detection result (in an asynchronous way!)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_webp_feature</span><span class="params">(feature, callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> kTestImages = &#123;</span><br><span class="line">        lossy: <span class="string">&quot;UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA&quot;</span>,</span><br><span class="line">        lossless: <span class="string">&quot;UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==&quot;</span>,</span><br><span class="line">        alpha: <span class="string">&quot;UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==&quot;</span>,</span><br><span class="line">        animation: <span class="string">&quot;UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = (img.width &gt; <span class="number">0</span>) &amp;&amp; (img.height &gt; <span class="number">0</span>);</span><br><span class="line">        callback(feature, result);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        callback(feature, <span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = <span class="string">&quot;data:image/webp;base64,&quot;</span> + kTestImages[feature];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中包含了对有损、无损、透明图、动图等 webp 图片的嗅探，这是一种最为保险的方法。不过缺点也很明显，在图片类型不一且量级较大的情况下，前端并不能知道哪些图片是有损，无损，抑或是透明的，也没用办法对其中一种特定类型做特定策略，所以即使知道不支持该类型的 webp，然而我们也没有办法主观的去做容错。所以这种方法只适合于图片类型单一，如开发者知道所有图片都是有损的，或是动图等，有针对性的去处理。</p><p>同时在处理的过程中，为了提高嗅探效率，嗅探之后可以将结果以本地存储的方式进行保存，如cookie ，方便下次直接进行调用。</p><h3 id="Request-Header"><a href="#Request-Header" class="headerlink" title="Request Header"></a>Request Header</h3><p>这种方式是较为符合标准的解决方案，浏览器在支持 webp 图片格式的情况下，会在请求的 http header accept 中携带 webp/image 的字段，后端接收到请求之后可以按照该形式来判断是否返回 webp 图片内容。</p><p>MIP 在实践中采用的是该方法，当用户访问 MIP Cache 上的页面时，不需要开发者替换图片，MIP Cache 根据 http header 自动决定是否返回 webp 图片内容。不过说到坑，依然也有，国内浏览器层出不群，大部分都向标准化的方向靠近，但仍然需要一定的时间来改善，所以过程中我们就发现了这样的问题，虽然 http header accept 中包含了 webp/image 的字段，但实际上是不支持 webp 格式的（华为 MT7 自带浏览器），具体体现在动图（animation）的 feature 上。</p><p>其实解决方案也很简单，就是在 webp 图片加载失败后发起原图请求，让图片能够正确的展示在页面上。具体可以通过 img onerror 函数进行判断。</p><h2 id="转换工具？"><a href="#转换工具？" class="headerlink" title="转换工具？"></a>转换工具？</h2><p>webp 的转换工具很多，主要包含了命令行和可视化界面两种：</p><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>官方对于每一种 webp 格式也分别提供了对应的<a href="https://developers.google.com/speed/webp/download">转换工具</a>，主要包含了cwebp、dwebp、vwebp、webpmux、gif2webp 等几种，开发者可以择优选择！</p><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>页面也提供了不同可视化的软件进行 webp 格式图片转换，如：<a href="http://isparta.github.io/">iSparta</a>。</p><p>webp 作为一种新型图片格式，不但能够节省流量，减少图片体积，一定程度上也可以优化用户体验，同时 MIP 团队也在这方面不断迭代前行，致力于打造极致的用户体验！</p>]]></content>
      
      
      
        <tags>
            
            <tag> MIP </tag>
            
            <tag> WEBP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Secrets-快捷键</title>
      <link href="/2017/08/05/GitHub-Secrets-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2017/08/05/GitHub-Secrets-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>GitHub 由来已久，而你对他的了解又有多少？心血来潮，想探探 GitHub 提供的各种优秀功能和黑科技，也就有了这个系列文章的开端。本篇为入门篇，罗列一些 GitHub 在使用过程中简化操作的快捷键功能。</p></blockquote><h3 id="GitHub-全网快捷键"><a href="#GitHub-全网快捷键" class="headerlink" title="GitHub 全网快捷键"></a>GitHub 全网快捷键</h3><ul><li>s: 光标定位到 search 框<img src="/img/articles/github-secrets/s.jpeg" width=600></li><li>g + n: 定位到 Notifications 页<img src="/img/articles/github-secrets/n.jpeg" width=600></li><li>g + d: 定位到 Dashboard 页</li><li>?: 显示快捷键列表</li><li>j: 仓库文件向下选择<img src="/img/articles/github-secrets/down.jpeg" width=600></li><li>k: 仓库文件向上选择<img src="/img/articles/github-secrets/up.jpeg" width=600></li><li>x:</li><li>o/enter: 打开选中的文件/文件夹</li></ul><h3 id="仓库级别快捷键"><a href="#仓库级别快捷键" class="headerlink" title="仓库级别快捷键"></a>仓库级别快捷键</h3><ul><li>g + c: 定位到仓库 code tab</li><li>g + i: 定位到仓库 code issue tab</li><li>g + p: 定位到仓库 code pull request tab</li><li>g + w: 定位到仓库 code tab wiki tab</li></ul><h3 id="源码级别快捷键"><a href="#源码级别快捷键" class="headerlink" title="源码级别快捷键"></a>源码级别快捷键</h3><ul><li>t: 激活搜索功能，可以在仓库下搜索匹配文件，包含 auto complete<img src="/img/articles/github-secrets/t.jpeg" width=600></li><li>l: 跳转到具体行，只有在具体文件下生效<img src="/img/articles/github-secrets/l.jpeg" width=600></li><li>w: 切换仓库分支<img src="/img/articles/github-secrets/w.jpeg" width=600></li><li>y:</li><li>i:</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Pages 部署 https</title>
      <link href="/2017/07/30/Github-Pages-%E9%83%A8%E7%BD%B2-https/"/>
      <url>/2017/07/30/Github-Pages-%E9%83%A8%E7%BD%B2-https/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不用多说大家也知道，https 是向网络安全进发的必经之路，同时也是推进 http 2.0 经历的一个阶段，目前很多大站都已经部署了 https，比如百度，淘宝。</p></blockquote><p>对于有强迫症的开发者来说，一定忍受不了下面这种情况，在 <strong>chrome://flags/</strong> 中开启了 Mark non-secure origins as non-secure 的情况下，浏览器地址拦会出现一道不安全的红色显眼字眼。</p><img width=500 src="/img/articles/github-pages-https/chrome-https-1.jpeg"><img width=500 src="/img/articles/github-pages-https/chrome-https-2.jpeg"><p>这篇文章分享是：以 hexo 搭建个人网站，并将域名解析到个人申请的域名后，如何搭建 https 服务。很多人眼中 https 服务的搭建一定是要有自己的服务器、一定是动态网站、一定得有证书才能进行，那么诸如 hexo 搭建的这样一些纯静态的网站想要部署 https 可谓望成莫及，其实不然，一些免费的服务商已经为我们提供好了一整套服务，比如 CloudFlare、又拍云、七牛等 CDN 提供厂商。网站会基于服务商提供的免费功能动态获取证书，并为我们生成 https 服务。本文基于 <a href="https://www.cloudflare.com/">CloudFlare</a> 进行讲解。</p><h4 id="一、域名解析"><a href="#一、域名解析" class="headerlink" title="一、域名解析"></a>一、域名解析</h4><p>我们在申请域名后通常会将其解析到 @ 和 www 下，不论是以 cname 的方式还是以 IPV4 等其他方式。如果你希望通过 CloudFlare 来部署 https，那么需要修改一下之前的配置：</p><p>** 1. 顶级域名解析 **</p><p>将顶级域名解析到 CloudFlare 提供的以下两个 ip 上，可参考 <a href="https://help.github.com/articles/setting-up-an-apex-domain/#configuring-a-records-with-your-dns-provider">官方说明</a>，这里域名厂商以万网域名为例</p><p><img src="/img/articles/github-pages-https/DNS-1.jpeg"></p><p>** 2. cname 解析 **</p><p>默认网站已经添加了 cname 文件，作用是将域名 example.com 解析为 <a href="http://www.example.com/">www.example.com</a></p><p><img src="/img/articles/github-pages-https/DNS-2.jpeg"></p><p>** 3. 检测解析结果 **</p><p>可以通过以下命令进行检测，如果结果出现下图所示 ip，则说明解析已生效，否则就需要等待一段时间</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dig </span>+noall +answer</span><br></pre></td></tr></table></figure><p><img src="/img/articles/github-pages-https/DNS-3.jpeg"></p><h4 id="二、CloudFlare-注册站点信息"><a href="#二、CloudFlare-注册站点信息" class="headerlink" title="二、CloudFlare 注册站点信息"></a>二、CloudFlare 注册站点信息</h4><p>** 1. 扫描站点 **</p><p>目的是获取到 dns 解析信息，如果没有扫描出任何信息就需要手动添加</p><p><img src="/img/articles/github-pages-https/CloudFlare-1.jpeg"></p><p>** 2. 添加解析信息 **</p><p>按照图中进行添加即可</p><p><img src="/img/articles/github-pages-https/CloudFlare-2.jpeg"></p><p>** 3. 选择免费选项 **</p><p><img src="/img/articles/github-pages-https/CloudFlare-3.jpeg"></p><p>** 4. 配置域名厂商 ns 信息 **</p><p>在进行了上一步之后会来到这个界面，里面提供了 name server 信息，用于域名解析服务地址</p><p><img src="/img/articles/github-pages-https/CloudFlare-4.jpeg"></p><p>到域名服务厂商管理页面进行修改，替换为上图产出的 ns 地址，仍以万网为例</p><p><img src="/img/articles/github-pages-https/CloudFlare-5.jpeg"></p><p>** 5. 配置 Crypto **</p><p>在 CloudFlare 上设置完上一步之后需要配置下 ssl 模式，选择 full 模式，目的是全站都走 https 协议</p><p><img src="/img/articles/github-pages-https/CloudFlare-6.jpeg"></p><p>** 6. 配置 Page Rules **</p><p>一般来说只需要配置一个规则，匹配路径，强制走 https 即可，如果还有其他需求可以自己设置</p><p><img src="/img/articles/github-pages-https/CloudFlare-7.jpeg"></p><p>** 7. check 结果 **</p><p>以上所有的工作都已就绪，可以访问网站试试效果，如果暂时还没有走 https，可能是需要一段生效时间，耐心等待吧，同时也可以在 overview 里查看设置信息生效情况</p><p><img src="/img/articles/github-pages-https/CloudFlare-8.jpeg"></p><p>至此，你就可以看到一个完整的 <a href="http://itoss.tech/">https 案例</a>了<br><img src="/img/articles/github-pages-https/website-https.jpeg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Github Pages </tag>
            
            <tag> HTTPS </tag>
            
            <tag> CloudFlare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何构建开源项目 CI 机制</title>
      <link href="/2017/07/18/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-CI-%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/07/18/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-CI-%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>很久没有发布新文章了，最近几天一直在搞开源项目持续集成机制这一块的事情，今天算是告一段落了，把自己在这几天遇到的坑和用到的工具，技术整理成了一片文章，一是作为总结，二是作为分享，希望有类似经历的开发者可以参考！</p></blockquote><h4 id="一、什么是-CI"><a href="#一、什么是-CI" class="headerlink" title="一、什么是 CI?"></a>一、什么是 CI?</h4><p>CI 是 Continuous integratio 的缩写，中文名称是持续集成。他作为开源项目必不可少的一个环节，不但可以规范编码方式，也可以直观的提供给开发者一种项目质量的信息。相信很多人也都看到过持续集成之后的结果，他是以 README.md 的形式体现在项目中的，比如最近做的 <a href="https://github.com/mipengine/mip">MIP项目</a>。</p><p align='center'>    <a href="https://github.com/mipengine/mip">        <img src='/img/articles/mip-ci/mipci.jpeg' width=500 title='MIP 项目持续集成' alt='MIP 项目持续集成'>    </a></p><h4 id="二、为什么要做持续集成？"><a href="#二、为什么要做持续集成？" class="headerlink" title="二、为什么要做持续集成？"></a>二、为什么要做持续集成？</h4><ul><li><strong>提高代码质量</strong><p>前端开源项目持续集成的核心模块是单元测试，他是通过输入（Input）来执行我们所开发的代码模块，检测输出（Output）是否和预期一致的一个环节。在这一部分，最直观的结果就是代码覆盖率的指标，覆盖率越高，代码被运行的越全面，出现问题的几率越少，目前来说单元测试的框架也比较多，如较为流行的 [mocha](http://mochajs.org/)，同时我们可以借助 [circleci](https://circleci.com/) 或 [travis](https://travis-ci.org/) 等平台来帮助我们在线跑单元测试。另外单元测试的语法在一定程度上可以帮助我们规避不优雅的代码写法。对于单元测试语法，这里不讲解，大家可以通过断言库进行了解，如 [chai](http://chaijs.com/)；</p></li><li><strong>自动化覆盖多个浏览器</strong><p>我们所开发的单元测试，可以在多个浏览器上进行 build，可以通过这样的结果来查看自己代码在不同浏览器上是否存在问题，解决了手动测试的时间成本，可以使用的工具有 [saucelabs](https://saucelabs.com/) 或 [browserstack](https://www.browserstack.com/)；</p></li><li><strong>实时获取代码运行状态和质量信息</strong><p>通过在线构建平台及其生成的 badge （徽章）我们可以及时知道在提交代码后，代码构建是否通过，覆盖率提高还是降低了，具体哪个地方引起了问题，以帮助我们在出现问题后及时修改；</p></li><li><strong>对外展示的信息</strong><p>从开源项目的使用者来说，通过 badge 可以直观的看出一个开源项目的好坏，能够给他们一种心理暗示说我是不是敢用这个项目，项目是否活跃等。当然，如果项目质量太差的话还是不要把 badge 挂出来了，会吓走开发者的...</p></li></ul><h4 id="三、持续集成构建利器"><a href="#三、持续集成构建利器" class="headerlink" title="三、持续集成构建利器"></a>三、持续集成构建利器</h4><p>在这篇文章里会结合 Mocha + Chai + Karma + Travis + Coveralls + SauceLabs 这几种利器和大家介绍一些开源项目中如何把持续集成跑起来。</p><ul><li><strong>Mocha + Chai + Karma</strong><p>Mocha 是一种单元测试技术，Chai 是单元测试的断言库，Karma 主要目的是为开发人员提供一个有效的测试环境，三者搭配使用会很方便的构建出一个单元测试的环境。他们既可以在本地跑单测试，也可以结合 travis，circleci等平台进行构建，下图是通过以上三种技术在本地跑单元测试的截图：![](/img/articles/mip-ci/unit-test.jpeg)</p></li><li><strong>Travis</strong><p>[Travis](https://travis-ci.org/) 是一个跑单元测试的平台，在与 GitHub 关联之后，在每次提交代码之后就会自动触发 travis 进行代码的构建，并最终产出单测结论的 badge，如下图中的绿色图标![](/img/articles/mip-ci/travis-1.jpeg)</p></li><li><strong>Coveralls</strong><p>[Coveralls](https://coveralls.io/) 是汇总代码覆盖率的一个平台，在单元测试完成之后，会将单元测试产出的结果上报到这个平台上，并由其最终汇总出一个总的覆盖率，并产出相应 badge。同时在该平台上我们可以看到每一个文件的覆盖率、每一次提交之后覆盖率的增减、以及具体增减是由谁引起的等等信息，我们可以根据这些信息有针对性的进行修改。![](/img/articles/mip-ci/coveralls-1.jpeg)<br>![](/img/articles/mip-ci/coveralls-2.jpeg)</p></li><li><strong>Sauce Labs</strong><p>[Sauce Labs](https://saucelabs.com/) 在不同浏览器上运行单元测试或者网站，并产出兼容性列表的一个平台。我们可以配置自己需要的浏览器，但是通过他提供的[浏览器支持列表](https://saucelabs.com/platforms)看出，目前只能配置 Chrome, firefox, ie, safari, android, iphone等选项，在每一次单元测试完成后会将生成的数据上报到 sauce labs 平台上，我们可以在这里查看具体构建信息。![](/img/articles/mip-ci/saucelabs.jpeg)</li></ul><h4 id="四、基于这套工具如何构建持续集成环境"><a href="#四、基于这套工具如何构建持续集成环境" class="headerlink" title="四、基于这套工具如何构建持续集成环境"></a>四、基于这套工具如何构建持续集成环境</h4><ul><li><strong>安装 mocha, karma, chai</strong><p>`npm i --save-dev mocha karma chai`</p></li><li><strong>配置 karma.conf.js</strong><p>具体配置可以在[官方网站](http://karma-runner.github.io/1.0/config/configuration-file.html)进行查看</p></li><li><strong>构建单元测试用例</strong><p>不在细说，大家了解单测语法后自行进行编码即可</p></li><li><strong>本地执行单测</strong><p>本地执行单元测试，看是否可以 run 起来，如果到这一步没有问题那我们就可以将本地单元测试这套机制和各个平台进行关联</p></li><li><strong>关联 Travis 平台</strong><ul><li>在 travis 平台上启用你需要的仓库<br><img src="/img/articles/mip-ci/travis-2.jpeg"></li><li>创建 travis.yml 配置文件，以下是我的一些配置，比较重要的是before_script，script和after_script，这一部分决定了你需要执行什么操作。具体信息也可以参考 <a href="https://github.com/mipengine/mip/blob/master/.travis.yml">MIP travis 配置</a>。<br><img src="/img/articles/mip-ci/travis-3.jpeg"></li><li>然后往仓库中 commit 就可以触发 travis 的构建功能</li></ul></li><li><strong>关联 Coveralls 平台</strong><ul><li>在 Coveralls 上启用需要的仓库<br><img src="/img/articles/mip-ci/coveralls-3.jpeg"></li><li>安装 karma-coveralls<br><code>npm i --save-dev karma-coveralls</code></li><li>将 karma-coveralls 加入到 karma plugins 配置项中，他会自动生成上报所需要的 lcov 文件，具体信息可以参考 <a href="https://github.com/mipengine/mip/blob/master/scripts/unit/karma.cover.conf.js">MIP Cover 配置</a><br><img src="/img/articles/mip-ci/coveralls-4.jpeg"></li><li>配置上报参数，在 karma 配置文件的 reporters 中加入 coverage, coveralls 两个值即可。通过该参数，travis 构建后会自动将 lcon 数据上报到 coveralls，如果发现 travis 执行完成后在 coveralls 上没有数据，一般都是上报出现了问题，可以在 travis 中查看错误信息</li></ul></li><li><strong>关联 sauce labs 平台</strong><ul><li>配置 karma 参数，包括 browsers，customLaunchers，sauceLabs等，具体信息可以参考 <a href="https://github.com/mipengine/mip/blob/master/scripts/unit/karma.sauce.conf.js">MIP Sauce 配置</a></li><li>配置上报参数，同样，上报是必不可少的一步，只有这一步，平台才能拿到数据，配置方法很简单，在 karma 配置文件的 reporters 中加入 saucelabs 即可</li></ul></li><li><strong>获取 badge</strong><ul><li>将相关 badge 加入到项目 readme 中，每一个平台都会生成 badge，可以获取 markdown, html等多种格式</li></ul></li></ul><h4 id="五、坑列表"><a href="#五、坑列表" class="headerlink" title="五、坑列表"></a>五、坑列表</h4><ul><li>单元测试可以通过，但coveralls, saucelabs平台上没有数据<p>毋庸置疑，基本上都是上报出现了问题，在 travis log 中查看具体错误信息</p></li><li>Sauce Labs Safari 与 Coveralls 同时使用时构建超时<p>Saucelabs 测试浏览器包括 Safari，且执行了 Coveralls 的上报，这个时候会卡死在 Safari 单测那一步，直到超时，查看 GitHub issue 发现，这是 travis 的 bug，在使用了 istanbul 等库后就会出现该问题，解决办法是将 coveralls 和 saucelabs 任务分开执行，如 mip 将其区分为了 [karma-sauce.conf.js](https://github.com/mipengine/mip/blob/master/scripts/unit/karma.sauce.conf.js) 和 [karma-cover.conf.js](https://github.com/mipengine/mip/blob/master/scripts/unit/karma.cover.conf.js)，并通过travis 分别执行他们<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">script:</span><br><span class="line">  - npm <span class="keyword">run</span><span class="bash"> <span class="built_in">test</span></span></span><br><span class="line">  - npm <span class="keyword">run</span><span class="bash"> <span class="built_in">test</span>:sl</span></span><br><span class="line">  - npm <span class="keyword">run</span><span class="bash"> <span class="built_in">test</span>:co</span></span><br></pre></td></tr></table></figure></p>上面的一些步骤基本就可以完成持续集成环境的构建，当然坑都是自己踩了才知道，所以动手吧骚年，有问题欢迎在评论区交流！</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 开源 </tag>
            
            <tag> 构建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIP ACCESS 细节剖析</title>
      <link href="/2017/03/17/MIP-ACCESS-%E7%BB%86%E8%8A%82%E5%89%96%E6%9E%90/"/>
      <url>/2017/03/17/MIP-ACCESS-%E7%BB%86%E8%8A%82%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>MIP ACCESS</code>是一种页面访问权限控制机制，能够允许网页发布者在页面元素中定义内容标记，并结合用户访问情况进行综合评价，从而展现或隐藏页面中内容，直至用户登录、订阅或付费后才能够查看隐藏内容的一种全新阅读模式。</p></blockquote><br><h3 id="什么是MIP-ACCESS"><a href="#什么是MIP-ACCESS" class="headerlink" title="什么是MIP ACCESS"></a>什么是MIP ACCESS</h3><p><code>MIP ACCESS</code>是一种页面访问权限控制机制，能够允许网页发布者在页面元素中定义内容标记，并结合用户访问情况进行综合评价，从而展现或隐藏页面中内容，直至用户登录、订阅或付费后才能够查看隐藏内容的一种全新阅读模式。</p><h3 id="优势在哪里？"><a href="#优势在哪里？" class="headerlink" title="优势在哪里？"></a>优势在哪里？</h3><ul><li>方式新颖：页面中任何元素都能加入权限控制标记，并根据标记解析情况进行展示或隐藏，打破了传统阅读只展示前n字的模式；</li><li>形式多样：页面内容可以是任何元素，包括纯文本、图片、视频等；</li><li>数据驱动：内容展现与否直接与发布者配置的数据相关联，根据解析情况决定是否展示相应元素；</li><li>配置灵活：发布者可以根据不同的需求配置不同接口，如数据请求接口、访问记录接口、登录页面、登出页面等；</li></ul><h3 id="DEMO演示"><a href="#DEMO演示" class="headerlink" title="DEMO演示"></a>DEMO演示</h3><p>在说具体实现和细节之前，我们列举了四个<code>DEMO</code>认识一下<code>ACCESS</code>到底是一个怎样的存在吧！</p><ul><li><p><code>DEMO1</code>演示了<code>ACCESS</code>的基本功能，该案例提供了1篇首次点击免费文章和3篇免费文章，首次点击免费是指在第一次访问该域名下具有<code>ACCESS</code>功能的页面时免费查看的功能；如果访问文章数目超过4篇时，页面中配置有<code>ACCESS</code>属性的模块将会隐藏，登录后方可查看全部；</p><p><img src="/img/articles/mip-access/mip-access.gif" width="30%"></p></li><li><p><code>DEMO2</code>演示的是登录功能，案例制定的策略是登录后所有文章均免费查看；</p><p><img src="/img/articles/mip-access/mip-access-login.gif" width="30%"></p></li><li><p><code>DEMO3</code>演示了<code>ACCESS</code>登出功能，登出后受到权限限制；</p><p><img src="/img/articles/mip-access/mip-access-logout.gif" width="30%"></p></li><li><p><code>DEMO4</code>演示了重置数据的功能，重置会删除后端数据，由各自策略而定，在重置成功后所有页面的浏览记录均被删除；</p><p><img src="/img/articles/mip-access/mip-access-reset.gif" width="30%"></p></li></ul><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>在讲具体细节之前，大家先熟悉熟悉这些专有名词吧！</p><ul><li><code>Access Runtime</code>: MIP Javascript运行环境；</li><li><code>Access Content Markup</code>: 模块中以属性形式定义的，规定访问权限的标示；</li><li><code>Authorization endpoint</code>: 授权接口，返回<code>markup</code>解析数据；</li><li><code>Pingback endpoint</code>: 计量接口，存储访问数据；</li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul><li><p>开发者实现接口：所有接口的请求都依据<code>cors</code>方案，包括<code>Authorization</code>接口(返回解析<code>DOM</code>元素展示与否的数据)、<code>Pingback</code>接口，登陆相关接口相关逻辑；</p></li><li><p>引入<code>mip</code>脚本；</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://mipcache.bdstatic.com/static/v1/mip.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义<code>script</code>配置标签，并配置以下信息：</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">script</span> <span class="built_in">id</span>=<span class="string">&quot;mip-access&quot;</span> type=<span class="string">&quot;application/json&quot;</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;authorization&quot;</span>: <span class="string">&quot;https://publisher.com/mip-access/api/mip-authorization.json?rid=READER_ID&amp;url=CANONICAL_URL&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pingback&quot;</span>: <span class="string">&quot;https://publisher.com/mip-access/api/mip-pingback?rid=READER_ID&quot;</span>,</span><br><span class="line">  <span class="string">&quot;login&quot;</span>: <span class="string">&quot;https://publisher.com/mip-access/login/?rid=READER_ID&amp;url=CANONICAL_URL&quot;</span>,</span><br><span class="line">  <span class="string">&quot;authorizationFallbackResponse&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;error&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;access&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;client&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/<span class="keyword">script</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><p>authorization：授权接口，返回mip-access表达式中需要进行计算的数据；<br></p></li><li><p>pingback：计量接口，每次访问页面之后，通过该url发送请求到开发者服务器，由其对数据进行管理，如每访问一次计数减1；<br></p></li><li><p>noPingback：是否允许计量；<br></p></li><li><p>login：登陆相关接口，可以是一个map，如下:<br></p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;login&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;login&quot;</span>: <span class="string">&quot;https://publisher.com/login.html?rid=&#123;READER_ID&#125;&quot;</span>,</span><br><span class="line">     <span class="string">&quot;logout&quot;</span>: <span class="string">&quot;https://publisher.com/logout.html?rid=&#123;READER_ID&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>authorizationFallbackResponse：如果Authorization接口请求失败，需要在这里配置相关接口参数作为backup；</p>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;authorizationFallbackResponse&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;error&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;access&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>authorizationTimeout：Authorization接口请求超时时间，默认为3s；</p></li></ul></li><li><p>以<code>mip-access</code>属性来书写表达式</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">mip-access</span>=<span class="string">“access</span> <span class="attr">AND</span> <span class="attr">subscriber</span>”&gt;</span>…<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p><img src="/img/articles/mip-access/mip-access.png"><br><br>上图为纯前端方式实现<code>ACCESS</code>的时序图，下面就以这个引子来说一下<code>ACCESS</code>的工作流程吧！</p><ul><li>首先用户在访问页面时，请求会发送到<code>CDN</code>（页面嵌套在<code>Super Frame</code>中）或者开发者（单个<code>MIP</code>页面）自己的服务器上，此时返回<code>html</code>文档给用户，这样做是为了让用户能够第一时间看到页面，缩短请求的白屏时间；</li><li>在<code>html</code>文档返回之后启动<code>MIP Runtime</code>服务，并将页面中以<code>mip-access-hide</code>属性标记的所有<code>DOM</code>元素隐藏起来，同时根据开发中提供的<code>Authorization</code>接口发起请求；</li><li><code>Authorization</code>接口如果请求成功，则通过其返回的数据解析<code>html</code>文档中的<code>markup</code>，解析结果为<code>true</code>则展示元素，否则隐藏；如果请求失败，<code>MIP Runtime</code>会寻找<code>html</code>文档中以<code>mip-access</code>为标示的<code>script</code>，获取其中定义好的<code>JSON</code>数据，并以<code>authorizationFallbackResponse</code>字段中的内容作为解析需要的数据；如果<code>authorizationFallbackResponse</code>未定义则解析失败；</li><li>页面加载完成后如果开发者配置了<code>noPingback: true</code>的选项，则不会发起<code>Pingback</code>（该请求主要为了让<code>server</code>记录访问数据）请求；否则发起请求并将数据传递给开发者<code>server</code>进行保存，待下次访问根据状态返回相应的数据；</li></ul><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>目前来说，纯前端的<code>ACCESS</code>实现方案适用与一些不涉及用户信息和收费业务相关的简单页面，通过该方式可以自由化的配置页面中元素的展现方式；出于安全考虑和后续的需要，我们也会根据需求量来以前端+<code>server</code>的处理方式过滤<code>html</code>文档；</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>有任何问题可以到 <a href="https://github.com/mipengine/mip-extensions/issues">github issues</a> 提问。</p>]]></content>
      
      
      
        <tags>
            
            <tag> AMP </tag>
            
            <tag> Access </tag>
            
            <tag> MIP </tag>
            
            <tag> 设计方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIP ACCESS 实现方案</title>
      <link href="/2017/01/11/MIP-ACCESS-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
      <url>/2017/01/11/MIP-ACCESS-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者寄语：这是一套基于Google AMP Access的解决方案，其中example代表开发方，如AMP，可以参考改方案进行细节实施！</p></blockquote><ul><li><a href="#前言">前言</a></li><li><a href="#名词解释">名词解释</a></li><li><a href="#方案解读">方案解读</a></li><li><a href="#总体流程">总体流程</a></li><li><a href="#请求方案">请求方案</a></li><li><a href="#解析支持方式">解析支持方案</a></li><li><a href="#文档merge方案">文档merge方案</a></li><li><a href="#事件分析">事件分析方案</a></li></ul><h3 id='前言'> 一、前言 </h3> h3-ACCESS能够允许发布者对页面内容进行访问权限的控制，通过内容标记和用户访问情况进行综合评价，从而实现对付费墙和订阅功能的支持。 <h3 id='名词解释'> 二、名词解释 </h3>- Reader: 访客，浏览example文档的用户- Publisher: 发布商- Access Runtime: 执行文档的javascript运行环境- Access Content Markup: 模块中以属性形式定义的，规定访问权限的标示- Authorization endpoint: 授权端点- Pingback endpoint: 计量系统调用(类似统计)的端点- Example: 表示开发方<h3 id='方案解读'> 三、方案解读 </h3>- **开发者**  - 实现接口，所有接口的请求方式走cors，可参见<a href="#请求方案">请求方案</a>。包括授权接口(返回需要用到的markup)、计量接口（统计访问信息），登陆接口（将访客id与用户id对应，从而记录注册用户数据）相关逻辑；  - 引入example定义的脚本；  - 定义script配置标签，并配置以下信息：   <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">script</span> <span class="built_in">id</span>=<span class="string">&quot;example-access&quot;</span> type=<span class="string">&quot;application/json&quot;</span>&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;authorization&quot;</span>: <span class="string">&quot;https://rocky-sierra-1919.herokuapp.com/example-access/api/example-authorization.json?rid=READER_ID&amp;url=CANONICAL_URL&amp;ref=DOCUMENT_REFERRER&amp;_=RANDOM&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pingback&quot;</span>: <span class="string">&quot;https://rocky-sierra-1919.herokuapp.com/example-access/api/example-pingback?rid=READER_ID&amp;ref=DOCUMENT_REFERRER&amp;url=CANONICAL_URL&quot;</span>,</span><br><span class="line">    <span class="string">&quot;login&quot;</span>: <span class="string">&quot;https://rocky-sierra-1919.herokuapp.com/example-access/login/?rid=READER_ID&amp;url=CANONICAL_URL&quot;</span>,</span><br><span class="line">    <span class="string">&quot;authorizationFallbackResponse&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;error&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;access&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;client&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  &lt;/<span class="keyword">script</span>&gt;</span><br></pre></td></tr></table></figure>     1.authorization：授权接口，返回example-access表达式中需要进行计算的数据；     2.pingback：计量接口，每次访问页面之后，通过该url发送请求到开发者服务器，由其对数据进行管理，如每访问一次计数减1；     3.noPingback：是否允许计量；     4.login：登陆相关接口，可以是一个map，如下；       <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">”login<span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">   &quot;</span>signin<span class="string">&quot;: &quot;</span><span class="symbol">https:</span>/<span class="regexp">/publisher.com/signin</span>.html?rid=&#123;READER_ID&#125;<span class="string">&quot;,</span></span><br><span class="line"><span class="string">   &quot;</span>signup<span class="string">&quot;: &quot;</span><span class="symbol">https:</span>/<span class="regexp">/publisher.com/signup</span>.html?rid=&#123;READER_ID&#125;<span class="string">&quot;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br></pre></td></tr></table></figure>     5.authorizationFallbackResponse：如果授权接口请求失败，需要在这里配置相关接口参数作为backup；<pre><code>   <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;authorizationFallbackResponse&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;access&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 6.authorizationTimeout：授权接口请求超时时间，默认为3s；</code></pre><ul><li><p>以example-access属性来书写表达式<br><code>&lt;div example-access=“expression”&gt;…&lt;/div&gt;</code></p></li><li><p><strong>example前端</strong></p><ul><li>计量系统：负责每个模块展示策略统计数据的操作；在每次访问页面后，待页面加载完成，登录/登出后调用站长配置的pingback接口，将数据发送给站长服务器，由其控制计数的变化，如果计数达到站长要求的情况，则用户需登录，付费或进行其他操作，并满足要求之后才能继续访问页面，或页面中的模块；</li><li>登录系统：目前只支持站长提供登录地址自行管理数据的方式，后续会调研登录的整套流程和标准，加以扩充；</li></ul></li><li><p><strong>example后端</strong></p><ul><li>解析系统：负责expression解析。</li><li>example后端需要在用户请求后返回一个过滤了example-access元素的文档，使得页面第一时间展示，过滤具体方案参照<a href="#文档merge方案">文档merge方案</a>；</li><li>然后example后端调用授权接口获取相关数据，通过markup和数据共同决定是否要展示html元素，并将需要展示的返回给前端，前端进行替换加入到当前页面；</li></ul></li></ul><h3 id='总体流程'> 四、总体流程 </h3>- 1.整体时序图（如果是付费页面，通过后端数据标示，必须做到登录强相关）     <img src="http://upload-images.jianshu.io/upload_images/2483150-baa1c6bc470d5f3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width = "600" align=center /><ul><li><p>用户访问cache页面；</p></li><li><p>cache拿到的document会被server抓取到；</p></li><li><p><strong>server所要做的第一件事就是替换所有通过example-access定义的dom元素，然后返回给前端进行展示，这样做的目的是为了能让用户第一时间看到页面；</strong></p></li><li><p><strong>server所要做的第二件事是请求站长提供的授权接口authorization，根据返回授权数据和文档中的markup共同决定哪些模块需要显示，计算markup方式可参见<a href="#解析支持方式">解析支持方案</a>。并把需要显示的组装成html文档返回给前端，然后access runtime将其进行merge进当前页，具体merge方式可参见<a href="#文档merge方案">文档merge方案</a>；</strong></p></li><li><p>页面加载完成后access runtime调用计量接口，将相应访问统计数据进行操作，该操作策略由站长决定，如访问次数减1，目的是再次访问该站点页面时是否有权限访问，如果没有需要通过登录，付费等操作来继续访问。整个页面的事件方案可参见<a href="#事件分析">事件分析方案</a>；</p></li><li><p>登录：用户点击登录之后会调用站长提供的登录页面，如果登录成功则回调给access runtime，并刷新当前页面，页面逻辑从第一步开始；</p></li><li><p>2.流程图 <br>  <br><img src="http://upload-images.jianshu.io/upload_images/2483150-8f23bde37364b354.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width = "600" align=center /></p></li><li><p>3.ID系统（ID不会重复，ID是针对某个站点整站来说的）<br>  <br><img src="http://upload-images.jianshu.io/upload_images/2483150-f36c6456fec5e97f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width = "600" align=center /></p></li><li><p>4.计量系统<br>  <br><img src="http://upload-images.jianshu.io/upload_images/2483150-09ef1ec239419813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width = "600" align=center /></p></li><li><p>5.解析系统<br>获取所有example-access属性的dom，然后根据自定义的表达式进行展示和隐藏。</p></li></ul><h3 id='请求方案'> 五、请求方案 </h3>- 通过cors方式进行所有请求，目前百度有流量的浏览器都支持该协议；- 请求 - 通过`http header`中的`origin`判断必须是百度`cdn`域名或者`publisher`的`origin`; - 如果`http origin`不存在，`example`提供`example-Same-origin: true`来标示当前请求来自于同域名下的请求（同域名下请求不带`origin`）；如果该字段存在则允许，否则禁止访问； - `__example_source_origin`参数为同域名下`url`，可以通过其来替代`http header origin`不存在的情况；- 返回 - `Access-Control-Allow-Origin:<origin>`，允许哪些网站进行请求；不建议设置为*； - `example-Access-Control-Allow-Source-Origin: <source-origin>`，允许`source-origin`读取`authorization response`，通过__example_source_origin定义，他用来决定是否能够读取授权接口； - `Access-Control-Expose-Headers:example-Access-Control-Allow-Source-Origin`，允许`http`返回中包含该字段;<h3 id='解析支持方式'> 六、解析支持方式 </h3>[参见amp方式](https://github.com/ampproject/amphtml/blob/master/extensions/amp-access/0.1/access-expr-impl.jison)<h3 id='文档merge方案'> 七、文档merge方案 </h3>- 首先server返回首屏html文档时，将example-access标记的元素替换为example定义的一个空元素，并在元素中加入section_id属性作为标记，为的是之后合并匹配；- 同时server将替换前的dom元素保存在后端，并发起授权请求接口；- 拿到授权接口后执行markup表达式，将需要显示的元素组装成文档，返回给前端；- 拿到需要merge的文档后前端通过便利这些dom并通过section_id进行匹配，匹配到的话就将其替换为返回的新dom节点，从而达到更新的效果；<h3 id='事件分析'> 八、事件分析 </h3>参考[AMP Analytics](https://github.com/ampproject/amphtml/blob/master/extensions/amp-access/amp-access-analytics.md)]]></content>
      
      
      
        <tags>
            
            <tag> Google </tag>
            
            <tag> Access </tag>
            
            <tag> MIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说跨域那些事儿</title>
      <link href="/2016/12/31/%E8%AF%B4%E8%AF%B4%E8%B7%A8%E5%9F%9F%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
      <url>/2016/12/31/%E8%AF%B4%E8%AF%B4%E8%B7%A8%E5%9F%9F%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者寄语：首先纠正一个误区，跨域并非浏览器限制了发起跨站请求的这种能力，恰恰相反，我们可以发出请求，服务端也可以接收到请求并正常返回数据，只不过在返回之后浏览器会阻止非同源数据（response），从而在控制台打出一系列报错信息。</p></blockquote><h4 id="兼容性查找"><a href="#兼容性查找" class="headerlink" title="兼容性查找"></a>兼容性查找</h4><p>文章中会涉及一系列兼容性的图解（mdn &amp; can i use）和一些专有名词（mdn），可以通过两个渠道来查看</p><ul><li><a href="http://caniuse.com/">Can I Use</a></li><li><a href="https://developer.mozilla.org/en-US/">MDN</a></li></ul><h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h4><p>定义就不说了，从字面也可以看其含义，首先我们认识下哪些情况属于跨域，可以分为以下几点：</p><ul><li>协议不同，如http, https；</li><li>端口不同；</li><li>主域相同，子域不同；</li><li>主域不同；</li><li>ip地址和域名之间也算是跨域，浏览器不会自动做ip域名的映射；</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>document.domain</li><li>window.name</li><li>jsonp</li><li>postMessage</li><li>cors</li></ul><h4 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h4><ul><li>关键点<ul><li>跨域分为两种，一种xhr不能访问不同源的文档，另一种是不同window之间不能进行交互操作;</li><li><code>document.domain</code>主要是解决第二种情况，且只能适用于主域相同子域不同的情况；</li><li><code>document.domain</code>的设置是有限制的，我们只能把<code>document.domain</code>设置成自身或更高一级的父域，且主域必须相同。例如：<code>a.b.example.com</code>中某个文档的<code>document.domain</code>可以设成<code>a.b.example.com、b.example.com 、example.com</code>中的任意一个，但是不可以设成<code>c.a.b.example.com</code>，因为这是当前域的子域，也不可以设成baidu.com，因为主域已经不相同了。</li></ul></li><li>兼容性：所有浏览器都支持；</li><li>优点：<ul><li>可以实现不同window之间的相互访问和操作；</li></ul></li><li>缺点：<ul><li>只适用于父子window之间的通信，不能用于xhr；</li><li>只能在主域相同且子域不同的情况下使用；</li></ul></li><li>使用方式<ul><li>a（当前页面或父页面）页面中加入document.domain = ‘example.com’;</li><li>b（当前页面或子页面）页面中加入document.domain = ‘example.com’;</li><li>a页面访问b页面里面的数据或者方法；</li></ul></li></ul><h4 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h4><ul><li>关键点：window.name在页面的生命周期里共享一个window.name;</li><li>兼容性：所有浏览器都支持；</li><li>优点：<ul><li>最简单的利用了浏览器的特性来做到不同域之间的数据传递；</li><li>不需要前端和后端的特殊配制；</li></ul></li><li>缺点：<ul><li>大小限制：window.name最大size是2M左右，不同浏览器中会有不同约定；</li><li>安全性：当前页面所有window都可以修改，很不安全；</li><li>数据类型：传递数据只能限于字符串，如果是对象或者其他会自动被转化为字符串，如下；<br><img src="/img/articles/cross-domain/windowName.png" alt="window.name非字符串测试"></li></ul></li><li>使用方式：修改window.name的值即可；</li></ul><h4 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h4><ul><li>关键点：浏览器对XHR做了同源策略，但并没有将这种方式延续到script上（其实还有iframe，img等），从而可以利用动态script标签技术来做到跨域请求的作用。至于为什么会这样设计，本人也不太清楚，有可能是历史遗迹（漏洞），有可能是某些方面的技术瓶颈，也有可能是为了满足某些需求专门定制的，总之这项技术方案我们过去可以用，现在可以用就ok，至于将来应该也是会存在的，毕竟现在已经应用在很多家站点上，就算会废弃，也会有一段时间迭代。</li><li>兼容性：所有浏览器都兼容这种方式；</li><li>优点：很明显前端可以很轻松的做到跨域请求；</li><li>缺点<ul><li>只能通过GET方式请求，一方面是参数长度有限制，二是安全性比较差；</li><li>后端需要知道前端的cb是什么样的结构，主要在参数和回调名；</li><li>后端需要进行参数和cb的拼接然后才能执行；</li></ul></li><li>使用方式<figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">/** 前端生成script标签，并将src中传入需要执行的callback **/</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> ele = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    ele.type = <span class="string">&quot;text/javascript&quot;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    ele.src = <span class="string">&quot;http://example.com?jsonp=cb&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">document</span>.body.appendChild(ele);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">/** 后端接到参数后给callback加入参数并执行 **/</span></span><br><span class="line"><span class="xml"></span><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">    <span class="variable">$cb</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cb&#x27;</span>];</span></span><br><span class="line"><span class="php">    <span class="variable">$data</span> = <span class="keyword">array</span>(<span class="string">&#x27;test1&#x27;</span>, <span class="string">&#x27;test2&#x27;</span>, <span class="string">&#x27;test3&#x27;</span>);</span></span><br><span class="line"><span class="php">    <span class="keyword">echo</span> <span class="variable">$cb</span>.<span class="string">&#x27;(&#x27;</span>.json_encode(<span class="variable">$data</span>).<span class="string">&#x27;)&#x27;</span>;</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><ul><li>关键点：postMessage是h5引入的一个新概念，现在也在进一步的推广和发展中，他进行了一系列的封装，我们可以通过window.postMessage的方式进行使用，并可以监听其发送的消息；</li><li>兼容性：下图是postMessage的兼容图，移动端可以放心用，但是pc端需要做降级处理，具体可以根据文中介绍的这几种跨域方式来则情选择；<br><img src="/img/articles/cross-domain/postMessage.png" alt="poseMessage兼容性"></li><li>优点<ul><li>不需要后端介入就可以非常简单的的做到跨域，一个函数外加两个参数（请求url，发送数据）就可以搞定；</li><li>移动端兼容性好；</li></ul></li><li>缺点<ul><li>无法做到一对一的传递方式：监听中需要做很多消息的识别，由于postMessage发出的消息对于同一个页面的不同功能相当于一个广播的过程，该页面的所有onmessage都会收到，所以需要做消息的判断；</li><li>安全性问题：三方可以通过截获，注入html或者脚本的形式监听到消息，从而能够做到篡改的效果，所以在postMessage和onmessage中一定要做好这方面的限制；</li><li>发送的数据会通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">结构化克隆算法</a>进行序列化，所以只有满足该算法要求的参数才能够被解析，否则会报错，如function就不能当作参数进行传递；</li></ul></li><li>使用方式：下面是前段时间写的一个通信的函数，sendMessage_负责发送消息，bindEvent_负责消息的监听并处理，可以通过代码来做一个大致了解；<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Storage.prototype.sendMessage_ = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">type</span>, params, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.topWindow) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handleCookie_(<span class="keyword">type</span>, params, fn);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> eventId = <span class="built_in">this</span>.addToQueue_(fn, <span class="keyword">type</span>);</span><br><span class="line">    <span class="keyword">var</span> storageIframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;mip-storage-iframe&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    element.href = <span class="built_in">this</span>.origin;</span><br><span class="line">    <span class="keyword">var</span> origin = element.href.slice(<span class="number">0</span>, element.href.indexOf(element.pathname) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    storageIframe.contentWindow.postMessage(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="keyword">type</span>,</span><br><span class="line">        <span class="attr">params</span>: params,</span><br><span class="line">        <span class="attr">eventId</span>: eventId</span><br><span class="line">    &#125;, origin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Storage.prototype.bindEvent_ = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 判断消息来源</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span> == res.source.window.parent &amp;&amp;</span><br><span class="line">            res.data.type === <span class="built_in">this</span>.messageType.RES &amp;&amp;</span><br><span class="line">            <span class="built_in">window</span>.location.href.match(res.origin.host).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> fn = <span class="built_in">this</span>.eventQueue[res.data.eventId];</span><br><span class="line">            fn &amp;&amp; fn();</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.eventQueue[res.data.eventId];</span><br><span class="line">            <span class="comment">// reset id</span></span><br><span class="line">            <span class="keyword">var</span> isEmpty = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> <span class="built_in">this</span>.eventQueue) &#123;</span><br><span class="line">                isEmpty = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty) &#123;</span><br><span class="line">                <span class="built_in">this</span>.id = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.bind(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h4><ul><li>关键点：cors是一种通过前后端http header配置来进行跨域的一种方式；</li><li>兼容性：如果不考虑pc端的IE，移动端的opera的话那兼容性还是不错的，针对ie和opera可以做适当的降级处理；<br><img src="/img/articles/cross-domain/cors.png" alt="poseMessage兼容性"></li><li>安全策略<ul><li>请求<ul><li><code>origin</code>：通过<code>http</code>头中的<code>origin</code>判断域名是否是允许的；</li><li><code>Example-Same-origin</code>：如果<code>http origin</code>不存在，最好能够自己在请求头中加入该参数来标示是否是同源，<code>true</code>表示请求来自于同域名下（同域名下请求不带origin）；如果该字段存在并且为true则允许请求接口，否则禁止；</li><li><code>Example_source_origin</code>：该参数同<code>origin</code>，是在<code>origin</code>不存在的情况下用来标示请求来源的<code>url</code>；</li></ul></li><li>返回<ul><li><code>Access-Control-Allow-Origin: origin</code>，<code>origin</code>表示允许哪些网站请求，不建议设置为*；</li><li><code>Access-Control-Expose-Headers:Example-Access-Control-Allow-Source-Origin</code>，允许http返回中包含该字段，可以通过这种方式在返回头中加入自定义字段，如该例子中的<code>Example-Access-Control-Allow-Source-Origin</code>;</li></ul></li></ul></li><li>优点<ul><li>前端方便不少，只需要发请求而不用考虑跨域问题；</li><li>安全性能够得以控制和保障；</li></ul></li><li>缺点<ul><li>兼容性不全面，需要做降级处理；</li></ul></li><li>使用方式<ul><li>正常请求即可，无论是你要用xhr，还是用一些封装好的组件，如<a href="https://github.com/github/fetch">fetch</a>，<a href="https://github.com/camsong/fetch-jsonp">fetchJsonp</a>，亦或是jquery一类的技术均可；</li><li>后端在response时需要设置一定的配置参数，并保证安全策略，具体方案可以参照下面安全策略模块；</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google AMP Access 调研</title>
      <link href="/2016/12/10/Google-AMP-Access-%E8%B0%83%E7%A0%94/"/>
      <url>/2016/12/10/Google-AMP-Access-%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是对Google AMP ACCESS的探索和调研，究其具体运作流程，原理，实现和各种策略！</p></blockquote><br /><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p> AMP-ACCESS能够允许发布者对页面内容进行访问权限的控制，通过内容标记和用户访问情况进行综合评价，从而实现对付费墙和订阅功能的支持。</p><h4 id="二、名词解释"><a href="#二、名词解释" class="headerlink" title="二、名词解释"></a>二、名词解释</h4><ul><li>Reader: 访客，浏览AMP文档的用户</li><li>Publisher: 发布商</li><li>AMP Runtime: 执行AMP文档的javascript运行环境</li><li>Access Content Markup: 模块中以属性形式定义的，规定访问权限的标示</li><li>Authorization endpoint: 授权端点</li><li>Pingback endpoint: 计量系统调用（类似统计）的端点</li></ul><h4 id="三、ACCESS机制职责"><a href="#三、ACCESS机制职责" class="headerlink" title="三、ACCESS机制职责"></a>三、ACCESS机制职责</h4><ul><li>创建和维护用户</li><li>控制计量（允许一定数量的自由视图）</li><li>负责登录</li><li>负责验证用户</li><li>负责访问权限和授权控制</li><li>基于访问参数进行灵活配置</li></ul><h4 id="四、组成模块"><a href="#四、组成模块" class="headerlink" title="四、组成模块"></a>四、组成模块</h4><ul><li>AMP Reader ID<ul><li>由AMP机制生成；</li><li>唯一标示Reader-Publisher对；</li><li>发布者用其标示每个访问者，并与身份库进行映射；</li><li>ID以设备进行构造，有限期为1年，或者止于清除cookie；</li><li>ID不能在多设备之间共享；</li></ul></li><li> Access Content Markup</li><li>由发布者定义，控制页面模块的访问权限；</li><li>以html标签属性形式存在，如<code>&lt;div amp-access=“access”&gt;</code>；</li><li>与Authorization endpoint共同决定网页模块是否展示；</li><li>Authorization endpoint<ul><li>由发布者定义，描述文档的哪一部分可以使用；</li><li>被AMP Cache/ AMP Runtime调用；</li><li>返回访问参数，如access, subscriber等；</li><li>在header的script中进行配置；</li><li>协助解析markup；</li></ul></li><li>Pingback endpoint<ul><li>由发布者定义，描述访问状态；</li><li>被AMP Cache/ AMP Runtime调用；</li><li>在用户浏览页面或成功登陆之后调用；</li><li>记录和更新计量信息；</li><li>可以设置noPingback: true来禁止；</li></ul></li><li>Login Link and Login Page<ul><li>验证用户；</li><li>将用户身份与AMP ID连接起来；</li></ul></li></ul><h4 id="五、流程"><a href="#五、流程" class="headerlink" title="五、流程"></a>五、流程</h4><p><img src="/img/articles/google-amp/google-access-timing-diagram.png" alt="整体功能流程图"><br><img src="/img/articles/google-amp/google-access-flow-chart.png" alt="整体功能时序图"></p><ul><li>加载页面时，如果有缓存，从AMP Cache上获取数据，否则从Server取数据。其中获取的数据中包含markeup信息；</li><li>请求成功之后，AMP Runtime调用Authorization endpoint机制来拿到授权参数，再跟返回数据中的markup进行比对(执行markup表达式)；表达式执行的结果（true/false）则决定是否展示该模块；</li><li>如果请求失败，则从返回文档的配置信息中（head-&gt;script中定义)读取配置，如果该配置信息存在，则通过配置中的authorizationFallbackResponse获取授权参数；若authorizationFallbackResponse没有被定义，则不执行markup表达式，此时模块是否展示取决于初始化文档时是否定义了amp-access-hide属性，如果定义了则隐藏，否则展示；</li><li>AMP Runtime决定哪些模块需要展示之后将完整页面展示给用户；<br>在用户浏览或者登陆完成之后，AMP Runtime会调用Pingback endpoint机制来进行计量计算，该操作主要记录访问者的访问状态，如某个模块对于每个访客最多允许访问多少次，目前已经访问了多少次，这样可以保证再次访问时AMP Runtime可以做出正确的展示策略； </li></ul><h4 id="六、文档配置信息"><a href="#六、文档配置信息" class="headerlink" title="六、文档配置信息"></a>六、文档配置信息</h4><p>在页面head的script中进行配置，包括以下一些信息；</p><ul><li>authorization：授权参数返回接口；</li><li>pingback：计量接口；</li><li>noPingback：是否使用pingback;</li><li>login：登陆地址；</li><li>authorizationFallbackResponse：如果请求失败，通过该对象自定义授权参数；</li><li>authorizationTimeout：超时时间；</li><li>type：平台参数，规定适用于的平台，如client，server； </li></ul><h4 id="七、安全策略"><a href="#七、安全策略" class="headerlink" title="七、安全策略"></a>七、安全策略</h4><p>Authorization endpoint和Pingback endpoint都是机遇CORS(跨源资源共享)机制的，需要实现相应的安全协议；</p><h4 id="八、计量系统"><a href="#八、计量系统" class="headerlink" title="八、计量系统"></a>八、计量系统</h4><p>计量系统是一个通过访问限制来控制页面展示周期的模块，比如页面某个模块的免费访问次数为10次，在超过该计量后，会显示付费踢墙等操作；<br>计量数据的记录依赖于READER _ID，且该信息存储于服务端；<br>该信息在每次Pingback endpoint中更新；</p><h4 id="九、首次点击免费"><a href="#九、首次点击免费" class="headerlink" title="九、首次点击免费"></a>九、首次点击免费</h4><p>第一次点击免费策略；</p><h4 id="十、ACCESS如何与自己项目结合"><a href="#十、ACCESS如何与自己项目结合" class="headerlink" title="十、ACCESS如何与自己项目结合"></a>十、ACCESS如何与自己项目结合</h4><ul><li>要实现这一整套机制，同样需要由上述第二点的六个模块组成，并实现其各个流程；</li><li>协同前端+后端+CDN配合使用，来进行文档和数据的筛选和存储；</li><li>制定一套稳固的策略，包括展示策略，安全策略，以及通信策略；</li></ul><h4 id="十一、附件"><a href="#十一、附件" class="headerlink" title="十一、附件"></a>十一、附件</h4><ul><li><a href="https://www.ampproject.org/zh_cn/docs/reference/components/amp-access#access-url-variables">官方文档</a>;</li><li><a href="https://ampbyexample.com/components/amp-access/">案例页面</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> AMP </tag>
            
            <tag> Google </tag>
            
            <tag> Access </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端动画库设计及实现</title>
      <link href="/2016/12/07/%E5%89%8D%E7%AB%AF%E5%8A%A8%E7%94%BB%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2016/12/07/%E5%89%8D%E7%AB%AF%E5%8A%A8%E7%94%BB%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者寄语：该文章讲解动画库设计思想和具体实现方式，欢迎大家到源码查看并提出意见。</p></blockquote><br /><h4 id="一、Usage"><a href="#一、Usage" class="headerlink" title="一、Usage"></a>一、Usage</h4><ul><li><code>npm install io-animation</code></li></ul><h4 id="二、测试case"><a href="#二、测试case" class="headerlink" title="二、测试case"></a>二、测试case</h4><ul><li>查看<a href="http://naotu.baidu.com/file/c256288088a1359a6dcdadd90cc6b0cc?token=086cb65c016d2bd2">百度脑图</a>附件</li></ul><h4 id="三、测试页面"><a href="#三、测试页面" class="headerlink" title="三、测试页面"></a>三、测试页面</h4><ul><li>见<a href="https://github.com/wupengFEX/animation">github demo</a></li></ul><h4 id="四、设计目的"><a href="#四、设计目的" class="headerlink" title="四、设计目的"></a>四、设计目的</h4><ul><li>功能<ul><li>提高动画性能，css3 transition实现；</li><li>支持动画播放/暂停；</li></ul></li><li>兼容<ul><li>不支持transition，通过setTimeout实现；</li></ul></li><li>写法<ul><li>支持链式写法；</li><li>支持非链式写法；</li></ul></li><li>执行顺序<ul><li>支持串行动画；</li><li>支持并行动画；</li><li>支持串行&amp;并行结合动画（JQuery&amp;Zepto不支持）；</li><li>支持多dom动画（通过类选择器，默认为并行）；</li></ul></li><li>类型<ul><li>支持普通动画；</li><li>支持transform动画；</li><li>不支持keyframe动画；</li></ul></li><li>回调<ul><li>支持串行回调；</li><li>支持并行回调；</li><li>支持并行动画全部执行完成的回调；</li></ul></li></ul><h4 id="五、案例"><a href="#五、案例" class="headerlink" title="五、案例"></a>五、案例</h4><ul><li><p>单对象串行；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">animate(propDomCallbackBtn1, &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="string">&quot;70%&quot;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  duration: <span class="number">1000</span>,</span><br><span class="line">  easing: <span class="string">&quot;ease&quot;</span>,</span><br><span class="line">  cb: function () &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">&quot;串行1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="selector-class">.animate</span>(propDomCallbackBtn2, &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  duration: <span class="number">3000</span>,</span><br><span class="line">  easing: <span class="string">&quot;ease&quot;</span>,</span><br><span class="line">  cb: function () &#123;</span><br><span class="line">      console.<span class="built_in">log</span>(<span class="string">&quot;串行2&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>单对象并行；</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">animate(propDomCallbackBtn1, &#123;</span><br><span class="line"><span class="symbol">    width:</span> <span class="string">&quot;70%&quot;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="symbol">  duration:</span> <span class="number">1000</span>,</span><br><span class="line"><span class="symbol">  easing:</span> <span class="string">&quot;ease&quot;</span>,</span><br><span class="line"><span class="symbol">  delay:</span> <span class="number">2000</span>,</span><br><span class="line"><span class="symbol">  isAsync:</span> <span class="number">1</span>,</span><br><span class="line"><span class="symbol">  cb:</span> function () &#123;</span><br><span class="line">      console.log(<span class="string">&quot;并行1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.animate(propDomCallbackBtn2, &#123;</span><br><span class="line"><span class="symbol">    height:</span> <span class="number">200</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="symbol">  duration:</span> <span class="number">3000</span>,</span><br><span class="line"><span class="symbol">  easing:</span> <span class="string">&quot;ease&quot;</span>,</span><br><span class="line"><span class="symbol">  isAsync:</span> <span class="number">1</span>,</span><br><span class="line"><span class="symbol">  cb:</span> function () &#123;</span><br><span class="line">      console.log(<span class="string">&quot;并行2&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.endAnimaion(function() &#123;</span><br><span class="line">    console.log(<span class="string">&quot;并行动画全部执行完成&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>单对象串行&amp;并行；</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">animate(propDomCallbackBtn1, &#123;</span><br><span class="line"><span class="symbol">    width:</span> <span class="string">&quot;70%&quot;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="symbol">  duration:</span> <span class="number">1000</span>,</span><br><span class="line"><span class="symbol">  easing:</span> <span class="string">&quot;ease&quot;</span>,</span><br><span class="line"><span class="symbol">  isAsync:</span> <span class="number">1</span>,</span><br><span class="line"><span class="symbol">  cb:</span> function () &#123;</span><br><span class="line">      console.log(<span class="string">&quot;并行1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.animate(propDomCallbackBtn2, &#123;</span><br><span class="line"><span class="symbol">    height:</span> <span class="number">200</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="symbol">  duration:</span> <span class="number">3000</span>,</span><br><span class="line"><span class="symbol">  easing:</span> <span class="string">&quot;ease&quot;</span>,</span><br><span class="line"><span class="symbol">  isAsync:</span> <span class="number">1</span>,</span><br><span class="line"><span class="symbol">  cb:</span> function () &#123;</span><br><span class="line">      console.log(<span class="string">&quot;并行2&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.start(function() &#123;</span><br><span class="line">    console.log(<span class="string">&quot;并行动画全部执行完成&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.animate(propDomCallbackBtn2, &#123;</span><br><span class="line"><span class="symbol">    height:</span> <span class="number">200</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="symbol">  duration:</span> <span class="number">3000</span>,</span><br><span class="line"><span class="symbol">  easing:</span> <span class="string">&quot;ease&quot;</span>,</span><br><span class="line"><span class="symbol">  cb:</span> function () &#123;</span><br><span class="line">      console.log(<span class="string">&quot;串行1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>多对象并行；</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">animate(propDomCallbackBtn1, &#123;</span><br><span class="line"><span class="symbol">    width:</span> <span class="string">&quot;70%&quot;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="symbol">  duration:</span> <span class="number">1000</span>,</span><br><span class="line"><span class="symbol">  easing:</span> <span class="string">&quot;ease&quot;</span>,</span><br><span class="line"><span class="symbol">  delay:</span> <span class="number">2000</span>,</span><br><span class="line"><span class="symbol">  isAsync:</span> <span class="number">1</span>,</span><br><span class="line"><span class="symbol">  cb:</span> function () &#123;</span><br><span class="line">      console.log(<span class="string">&quot;串行1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.animate(propDomCallbackBtn1, &#123;</span><br><span class="line"><span class="symbol">    height:</span> <span class="number">200</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="symbol">  duration:</span> <span class="number">3000</span>,</span><br><span class="line"><span class="symbol">  easing:</span> <span class="string">&quot;ease&quot;</span>,</span><br><span class="line"><span class="symbol">  isAsync:</span> <span class="number">1</span>,</span><br><span class="line"><span class="symbol">  cb:</span> function () &#123;</span><br><span class="line">      console.log(<span class="string">&quot;串行1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.start(function() &#123;</span><br><span class="line">    console.log(<span class="string">&quot;并行动画全部执行完成1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">animate(propDomCallbackBtn2, &#123;</span><br><span class="line"><span class="symbol">    width:</span> <span class="string">&quot;70%&quot;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="symbol">  duration:</span> <span class="number">1000</span>,</span><br><span class="line"><span class="symbol">  easing:</span> <span class="string">&quot;ease&quot;</span>,</span><br><span class="line"><span class="symbol">  delay:</span> <span class="number">2000</span>,</span><br><span class="line"><span class="symbol">  isAsync:</span> <span class="number">1</span>,</span><br><span class="line"><span class="symbol">  cb:</span> function () &#123;</span><br><span class="line">      console.log(<span class="string">&quot;并行3&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.animate(propDomCallbackBtn2, &#123;</span><br><span class="line"><span class="symbol">    height:</span> <span class="number">200</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="symbol">  duration:</span> <span class="number">3000</span>,</span><br><span class="line"><span class="symbol">  easing:</span> <span class="string">&quot;ease&quot;</span>,</span><br><span class="line"><span class="symbol">  isAsync:</span> <span class="number">1</span>,</span><br><span class="line"><span class="symbol">  cb:</span> function () &#123;</span><br><span class="line">      console.log(<span class="string">&quot;并行4&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.start(function() &#123;</span><br><span class="line">    console.log(<span class="string">&quot;并行动画全部执行完成2&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="六、参数"><a href="#六、参数" class="headerlink" title="六、参数"></a>六、参数</h4></li><li><p>dom: dom元素，可以是一个元素，也可以是一个dom数组，不能为空；</p></li><li><p>property: 属性对象，不能为空；</p></li><li><p>opt: 动画相关参数</p><ul><li>opt.duration: 动画持续时间，如果不设置默认为0.4s；</li><li>opt.easing: 动画执行的形式, 如”ease, ease-in, ease-out, ease-in-out, linear, cubic-bezier”, 默认为”linear”;</li><li>opt.callback: 回调函数，在动画执行完成之后执行，分为两种，一种为单个动画执行完成之后的回调，另一种是所有并行动画执行完成的回调；</li><li>opt.delay: 延迟时间，如果不设置默认为0s；</li><li>opt.isAsync: 是否动画是并行，0为串行，1为并行;</li></ul></li></ul><h4 id="七、注意点"><a href="#七、注意点" class="headerlink" title="七、注意点"></a>七、注意点</h4><ul><li>动画需要调用start才能开始执行；</li><li>非链式写法是创建了多个对象，所以表现为并行动画，不能通过isAsync控制为串行；</li></ul><h4 id="八、设计方案概述"><a href="#八、设计方案概述" class="headerlink" title="八、设计方案概述"></a>八、设计方案概述</h4><ul><li>存储方案：单个对象串并行动画通过一个队列来进行存储；</li><li>多对象动画方案：通过生成多个对象来各自管理；</li><li>单对象动画方案：每个对象的串并行动画通过队列存储，以”#”分隔，每两个”#”之间代表一组并行动画，如果只有一个，则表现为串行形式；</li></ul><h4 id="九、详细设计方案"><a href="#九、详细设计方案" class="headerlink" title="九、详细设计方案"></a>九、详细设计方案</h4><ul><li><p>关键类</p><ul><li><p>入口类：每次单独（串行方式）调用一个<code>animate</code>函数时都会经过该类，他的主要作用是生成一个新的动画对象，并返回动画管理类，从而支持并行工作和链式调用，下面是其实现：</p><p>  <img src="http://upload-images.jianshu.io/upload_images/2483150-78c56ed41879b1cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="入口类"></p><p>  <img src="http://upload-images.jianshu.io/upload_images/2483150-3331fa9e51b54982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="入口类实现"></p></li><li><p>动画管理类：该类是管理每个对象生成的动画，包含三个主要属性和方法；</p><ul><li><code>isRuning</code>：当前动画执行状态，执行中/执行完成；</li><li><code>asyncQueue</code>：动画队列，存储串并行动画对象；</li><li><code>endCallback</code>：并行动画全部执行完成的回调队列；</li><li><code>animate(ele, property, opt)</code>：动画开始入口；</li><li><code>start(fn)</code>：结束并行动画，其中可以传入回调；</li><li><code>stop()</code>：停止当前动画；</li></ul><p>  <img src="http://upload-images.jianshu.io/upload_images/2483150-0e3ea78dc31dc08c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动画管理类"></p></li></ul></li><li><p>动画方案时序图：粗略的分为这几个块，starUML不太会用，有的生命周期可能画的不太对，先将就着看看<br><img src="http://upload-images.jianshu.io/upload_images/2483150-1366cb25b7e5bc23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动画时序图"></p><ul><li>第一步：首先一个动画对象进入之后会先初始化一个动画对象；</li><li>第二步：初始化后进入动画管理中心，进行单个动画管理；</li><li>第三步：动画正式开始之前会对动画的参数进行筛选和处理，比如集合属性的单位（<code>&#39;px&#39;</code>）处理，浏览器vendor处理（<code>&#39;webkit&#39;, &#39;moz&#39;, &#39;ms&#39;, &#39;o&#39;, &#39;Webkit&#39;, &#39;Moz&#39;, &#39;O&#39;</code>），是否支持transition处理等；</li><li>第四步：创建动画对象，并将其加入动画队列中；</li><li>第五步：开始执行动画；</li><li>第六步：动画执行完成之后进行该动画回调；</li><li>第七步：所有回调都执行完成之后进行并行动画终止回调的执行；</li><li>第八步：如果队列中仍然存在动画对象，执行下一个，跳转至步骤一；</li></ul></li></ul><h4 id="十、设计注意点"><a href="#十、设计注意点" class="headerlink" title="十、设计注意点"></a>十、设计注意点</h4><ul><li>transitionend多次执行：transitionend执行时机是每一个属性执行完成就会执行，所以你的动画有几个属性，他就会执行几次。这个比较好解决，在执行时remove了transitionend事件监听即可；但是如果多个并行动画执行在一个dom上时就蛋疼了，单纯remove监听是做不到的，可以通过判断动画delay+duration来判断是否是当前动画；</li><li>不支持transition怎么办：该实现方案采用的方式是，transition和setTimeout会同时执行，在一次回调处理时会clearTimeout和remove监听，从而做到双保险的作用；</li></ul><h4 id="十一、License"><a href="#十一、License" class="headerlink" title="十一、License"></a>十一、License</h4><p>MIT License</p><p>以上是大概的设计思路，具体可以在上面链接中深入到代码中查看！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 动画库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS Crash 栈解析</title>
      <link href="/2016/11/28/iOS-Crash-%E6%A0%88%E8%A7%A3%E6%9E%90/"/>
      <url>/2016/11/28/iOS-Crash-%E6%A0%88%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者寄语：该文章讲解iOS Crash栈解析的一些基本用法，用于入门级别以及日常问题处理，分别从准备工作，获取crash，获取符号表，解析前确认，解析等步骤进行讲解。</p></blockquote><br /><ul><li>准备工作<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">栈解析需要三个文件，分别是：<span class="string">.crash</span>, symbolicatecrash, <span class="string">.dSYM</span></span><br></pre></td></tr></table></figure></li><li>获取crash<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">苹果系统(OS X)：~<span class="regexp">/Library/Logs/CrashReporter/MobileDevice/</span></span><br><span class="line">其他：xcode-&gt;<span class="built_in">window</span>-&gt;Devices-&gt; &lt;DEVICE_NAME&gt; -&gt;View Devices Logs</span><br></pre></td></tr></table></figure></li><li>获取symbolicatecrash<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令：<span class="keyword">find</span> <span class="regexp">/Applications/</span>Xcode.app -name symbolicatecrash -type f</span><br></pre></td></tr></table></figure></li><li>获取dSYM<ul><li>如果是打包平台或者其他打包工具，可以通过在其上找到.dSYM</li><li>如果是Xcode开发中的app，可以在<code>commend+r</code>之后在Products中找到<code>Products-&gt;xx.app-&gt;show in finder</code></li></ul></li></ul><ul><li><p>解析前确认uuid：只有当xx.app, xxx.app.dSYM, crash文件这三者的uuid一致才能够解析出正确的日志文件</p></li><li><p>查看xx.app的uuid</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump <span class="comment">--uuid xx.app/xx</span></span><br></pre></td></tr></table></figure></li><li><p>查看xxx.app.dSYM的uuid</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump --uuid xx.app.dSYM<span class="regexp">/Contents/</span>Resources<span class="regexp">/DWARF/</span>xx</span><br></pre></td></tr></table></figure></li><li><p>查看crash文件的uuid：位于crash日志中的Binary Images中的第一行尖括号内</p></li><li><p>解析crash</p><ul><li>将<code>.crash, symbolicatecrash, .dSYM</code>放在一个文件夹中</li><li><code>export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer</code></li><li>命令行执行 <code>./symbolicatecrash yy.crash xx.dSYM &gt; xx.log</code></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Crash </tag>
            
            <tag> 栈解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人站点再次搭建起来啦</title>
      <link href="/2016/11/27/%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9%E5%86%8D%E6%AC%A1%E6%90%AD%E5%BB%BA%E8%B5%B7%E6%9D%A5%E5%95%A6/"/>
      <url>/2016/11/27/%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9%E5%86%8D%E6%AC%A1%E6%90%AD%E5%BB%BA%E8%B5%B7%E6%9D%A5%E5%95%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者寄语：有时候想一件事，就是单纯去做，不要畏首畏尾，行动派永远比理想派来的实际！</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=694286&auto=1&height=66"></iframe><p>记得第一次搭建个人网站是在14年了，那个时候本科刚毕业，怀着对前端的无限憧憬和热情，没有借助任何三方框架，纯手写了整个站点，而今一晃眼两年过去了。那时也恰逢来百度的前奏，说实话，万万没想到，最后竟然做了一年多的iOS，而也是那个时候，对自己的站点没有精心维护，导致VPS都过期回收了我才回来，愚蠢而又现实的是数据库连同VPS一起被销毁了，从那时起，再也没有想过去搭建网站！</p><p>一晃又一年过去了，心里一直想着要有一个地方，总结、分享、交流、沉淀，但是手头确实没有宽裕的时间，也就不了了之了。最近也是借着几天的闲暇时间，通过一些工具搞好了一个还罢了的地方，希望自己能够在这上面好好沉淀一些知识，也会将之前的一些总结和知识点慢慢迁移过来，欢迎大家来访交流！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 叙事 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
